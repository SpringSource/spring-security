[[test-mockmvc]]
== Spring MVC Test Integration

Spring Security provides comprehensive integration with https://docs.spring.io/spring/docs/current/spring-framework-reference/html/testing.html#spring-mvc-test-framework[Spring MVC Test]

[[test-mockmvc-setup]]
=== Setting Up MockMvc and Spring Security

[NOTE]
====
Spring Security's testing support requires spring-test-4.1.3.RELEASE or greater.
====

To use Spring Security with Spring MVC Test, add the Spring Security `FilterChainProxy` as a `Filter`.
You also need to add Spring Security's `TestSecurityContextHolderPostProcessor` to support <<running-as-a-user-in-spring-mvc-test-with-annotations,running as a user in Spring MVC test with annotations>>.
To do so, use Spring Security's `SecurityMockMvcConfigurers.springSecurity()`:

====
[source,java]
----
import static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SecurityConfig.class)
@WebAppConfiguration
public class CsrfShowcaseTests {

	@Autowired
	private WebApplicationContext context;

	private MockMvc mvc;

	@Before
	public void setup() {
		mvc = MockMvcBuilders
				.webAppContextSetup(context)
				.apply(springSecurity()) // <1>
				.build();
	}

...
}
----
<1> `SecurityMockMvcConfigurers.springSecurity()` will perform all of the initial setup we need to integrate Spring Security with Spring MVC Test
====

[[test-mockmvc-smmrpp]]
=== SecurityMockMvcRequestPostProcessors

Spring MVC Test provides a convenient interface (`RequestPostProcessor`) that you can use to modify a request.
Spring Security provides a number of `RequestPostProcessor` implementations that make testing easier.
To use Spring Security's `RequestPostProcessor` implementations, use the following static import:

====
[source,java]
----
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*;
----
====

[[test-mockmvc-csrf]]
==== Testing with CSRF Protection

When testing any non-safe HTTP methods and using Spring Security's CSRF protection, you must include a valid CSRF Token in the request.
To specify a valid CSRF token as a request parameter, use the following:

====
[source,java]
----
mvc
	.perform(post("/").with(csrf()))
----
====

If you like, you can include CSRF token in the header instead:

====
[source,java]
----
mvc
	.perform(post("/").with(csrf().asHeader()))
----
====

You can also test providing an invalid CSRF token by using the following:

====
[source,java]
----
mvc
	.perform(post("/").with(csrf().useInvalidToken()))
----
====

[[test-mockmvc-securitycontextholder]]
==== Running a Test as a User in Spring MVC Test

It is often desirable to run tests as a specific user.
There are two simple ways to populate the user:

* <<test-mockmvc-securitycontextholder-rpp,Running as a User in Spring MVC Test with RequestPostProcessor>>
* <<running-as-a-user-in-spring-mvc-test-with-annotations,Running as a User in Spring MVC Test with Annotations>>

[[test-mockmvc-securitycontextholder-rpp]]
==== Running as a User in Spring MVC Test with RequestPostProcessor

You have a number of options to associate a user to the current `HttpServletRequest`.
The following example runs as a user (which does not need to exist) whose username is `user`, whose password is `password`, and whose role is `ROLE_USER`:

====
[source,java]
----
mvc
	.perform(get("/").with(user("user")))
----
====

[NOTE]
====
The support works by associating the user to the `HttpServletRequest`.
To associate the request to the `SecurityContextHolder`, you need to ensure that the `SecurityContextPersistenceFilter` is associated with the `MockMvc` instance.
You can do so in a number of ways:

* Invoking <<test-mockmvc-setup,apply(springSecurity())>>
* Adding Spring Security's `FilterChainProxy` to `MockMvc`
* Manually adding `SecurityContextPersistenceFilter` to the `MockMvc` instance may make sense when using `MockMvcBuilders.standaloneSetup`
====

You can make customizations.
The following example runs as a user (which does not need to exist) whose username is `admin`, whose password is `pass`, and whose roles are `ROLE_USER` and `ROLE_ADMIN`.

====
[source,java]
----
mvc
	.perform(get("/admin").with(user("admin").password("pass").roles("USER","ADMIN")))
----
====

If you have a custom `UserDetails` object that you would like to use, you can specify that as well.
The following example uses the specified `UserDetails` (which does not need to exist) to run with a `UsernamePasswordAuthenticationToken` that has a principal of the specified `UserDetails`:

====
[source,java]
----
mvc
	.perform(get("/").with(user(userDetails)))
----
====

You can run as anonymous user by using the following:

====
[source,java]
----
mvc
	.perform(get("/").with(anonymous()))
----
====

This is especially useful when you run with a default user and wish to process a few requests as an anonymous user.

If you want a custom `Authentication` (which does not need to exist), you can do so by using the following:

====
[source,java]
----
mvc
	.perform(get("/").with(authentication(authentication)))
----
====

You can even customize the `SecurityContext`, by using the following:

====
[source,java]
----
mvc
	.perform(get("/").with(securityContext(securityContext)))
----
====

We can also ensure running as a specific user for every request by using the default request of `MockMvcBuilders`.
The following exampe runs as a user (which does not need to exist) whose username is `admin`, whose password is `password`, and whose role is `ROLE_ADMIN`:

====
[source,java]
----
mvc = MockMvcBuilders
		.webAppContextSetup(context)
		.defaultRequest(get("/").with(user("user").roles("ADMIN")))
		.apply(springSecurity())
		.build();
----
====

If you find yourself using the same user in many of your tests, we recommended moving the user to a method.
For example, you can specify the following in your own `CustomSecurityMockMvcRequestPostProcessors` class:

====
[source,java]
----
public static RequestPostProcessor rob() {
	return user("rob").roles("ADMIN");
}
----
====

Now you can perform a static import on `SecurityMockMvcRequestPostProcessors` and use that within your tests:

====
[source,java]
----
import static sample.CustomSecurityMockMvcRequestPostProcessors.*;

...

mvc
	.perform(get("/").with(rob()))
----
====
[[running-as-a-user-in-spring-mvc-test-with-annotations]]
===== Running as a User in Spring MVC Test with Annotations

As an alternative to using a `RequestPostProcessor` to create your user, you can use the annotations described in <<test-method>>.
The following example runs the test with a user whose username is `user`, whose password is `password`, and whose role is `ROLE_USER`:

====
[source,java]
----
@Test
@WithMockUser
public void requestProtectedUrlWithUser() throws Exception {
mvc
		.perform(get("/"))
		...
}
----
====

Alternatively, the following example runs the test with a user whose username is `user`, whose password is `password`, and whose role is `ROLE_ADMIN`:

====
[source,java]
----
@Test
@WithMockUser(roles="ADMIN")
public void requestProtectedUrlWithUser() throws Exception {
mvc
		.perform(get("/"))
		...
}
----
====

==== Testing HTTP Basic Authentication

While it has always been possible to authenticate with HTTP Basic, it was a bit tedious to remember the header name, format, and encode the values.
Now you can do so by using Spring Security's `httpBasic` `RequestPostProcessor`.
Consider the following snippet:

====
[source,java]
----
mvc
	.perform(get("/").with(httpBasic("user","password")))
----
====

The preceding line tries to use HTTP Basic to authenticate a user whose username is `user` and whose password is `password` by ensuring the following header is populated on the HTTP Request:

====
[source,text]
----
Authorization: Basic dXNlcjpwYXNzd29yZA==
----
====

[[testing-oauth2]]
==== Testing OAuth 2.0

When it comes to OAuth 2.0, the same principles covered earlier still apply: Ultimately, it depends on what your method under test is expecting to be in the `SecurityContextHolder`.

For example, consider the following controller:

====
[source,java]
----
@GetMapping("/endpoint")
public String foo(Principal user) {
    return user.getName();
}
----
====

There is nothing OAuth2-specific about it, so you can probably <<test-method-withmockuser,use `@WithMockUser`>> and be fine.

However, in cases where your controllers are bound to some aspect of Spring Security's OAuth 2.0 support, Spring Security's test support can come in handy:

====
[source,java]
----
@GetMapping("/endpoint")
public String foo(@AuthenticationPrincipal OidcUser user) {
    return user.getIdToken().getSubject();
}
----
====

[[testing-oidc-login]]
==== Testing OIDC Login

Testing the method above with Spring MVC Test requires simulating some kind of grant flow with an authorization server.
This can be a daunting task, which is why Spring Security ships with support for removing this boilerplate.

For example, we can tell Spring Security to include a default `OidcUser` by using the `SecurityMockMvcRequestPostProcessors#oidcLogin` method:

====
[source,java]
----
mvc
    .perform(get("/endpoint").with(oidcLogin()));
----
====

The preceding line configures the associated `MockHttpServletRequest` with an `OidcUser` that includes a `OidcIdToken`, an `OidcUserInfo`, and a `Collection` of granted authorities.

Specifically, it includes an `OidcIdToken` with a `sub` claim set to `user`:

====
[source,java]
----
assertThat(user.getIdToken().getClaim("sub")).isEqualTo("user");
----
====

It also includes an `OidcUserInfo` with no claims set:

====
[source,java]
----
assertThat(user.getUserInfo().getClaims()).isEmpty();
----
====

Finally, it includes a `Collection` of authorities with only one authority, `SCOPE_read`:

====
[source,java]
----
assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));
----
====

Spring Security does the necessary work to make sure that the `OidcUser` instance is available for <<mvc-authentication-principal,the `@AuthenticationPrincipal` annotation>>.

Further, it also links the `OidcUser` to an instance of `OAuth2AuthorizedClient` that it deposits into an mock `OAuth2AuthorizedClientRepository`.
This can be handy if your tests <<testing-oauth2-client,use the `@RegisteredOAuth2AuthorizedClient` annotation>>..

[[testing-oidc-login-authorities]]
===== Configuring Authorities

In many circumstances, your method is protected by filter or method security and needs your `Authentication` to have certain granted authorities to allow the request.

In this case, you can supply the granted authorities you need by using the `authorities()` method:

====
[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(oidcLogin()
            .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
        )
    );
----
====

[[testing-oidc-login-claims]]
===== Configuring Claims

While granted authorities are common across all of Spring Security, we also have claims, in the case of OAuth 2.0.

Suppose, for example, that you have a `user_id` claim that indicates the user's ID in your system.
You can then access it in a controller:

====
[source,java]
----
@GetMapping("/endpoint")
public String foo(@AuthenticationPrincipal OidcUser oidcUser) {
    String userId = oidcUser.getIdToken().getClaim("user_id");
    // ...
}
----
====

In that case, you want to specify that claim with the `idToken()` method:

====
[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(oidcLogin()
                .idToken(token -> token.claim("user_id", "1234"))
        )
    );
----
====

You need to do that because `OidcUser` collects its claims from `OidcIdToken`.

[[testing-oidc-login-user]]
===== Additional Configurations

There are additional methods for further configuring the authentication, depending on what data your controller expects:

* `userInfo(OidcUserInfo.Builder)`: For configuring the `OidcUserInfo` instance
* `clientRegistration(ClientRegistration)`: For configuring the associated `OAuth2AuthorizedClient` with a given `ClientRegistration`
* `oidcUser(OidcUser)`: For configuring the complete `OidcUser` instance

That last one is handy if you:
* Have your own implementation of `OidcUser`
* Need to change the name attribute

For example, suppose that your authorization server sends the principal name in the `user_name` claim instead of in the `sub` claim.
In that case, you can configure an `OidcUser` by hand:

====
[source,java]
----
OidcUser oidcUser = new DefaultOidcUser(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        Collections.singletonMap("user_name", "foo_user"),
        "user_name");

mvc
    .perform(get("/endpoint")
        .with(oidcLogin().oidcUser(oidcUser))
    );
----
====

[[testing-oauth2-login]]
==== Testing OAuth 2.0 Login

As with <<testing-oidc-login,testing OIDC login>>, testing OAuth 2.0 Login presents a similar challenge of mocking a grant flow.
And because of that, Spring Security also has test support for non-OIDC use cases.

Suppose that you have a controller that gets the logged-in user as an `OAuth2User`:

====
[source,java]
----
@GetMapping("/endpoint")
public String foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    return oauth2User.getAttribute("sub");
}
----
====

In that case, you can tell Spring Security to include a default `OAuth2User` by using the `SecurityMockMvcRequestPostProcessors#oauth2User` method:

====
[source,java]
----
mvc
    .perform(get("/endpoint").with(oauth2Login()));
----
====

This line configures the associated `MockHttpServletRequest` with an `OAuth2User` that includes a simple `Map` of attributes and a `Collection` of granted authorities.

Specifically, it includes a `Map` with a key/value pair of `sub`/`user`:

====
[source,java]
----
assertThat((String) user.getAttribute("sub")).isEqualTo("user");
----
====

It also includes a `Collection` of authorities with only one authority, `SCOPE_read`:

====
[source,java]
----
assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));
----
====

Spring Security does the necessary work to make sure that the `OAuth2User` instance is available for <<mvc-authentication-principal,the `@AuthenticationPrincipal` annotation>>.

Further, it also links that `OAuth2User` to an instance of `OAuth2AuthorizedClient` that it deposits in a mock `OAuth2AuthorizedClientRepository`.
This can be handy if your tests <<testing-oauth2-client,use the `@RegisteredOAuth2AuthorizedClient` annotation>>.

[[testing-oauth2-login-authorities]]
===== Configuring Authorities

In many circumstances, your method is protected by filter or method security and needs your `Authentication` to have certain granted authorities to allow the request.

In those cases, you can supply what granted authorities you need by using the `authorities()` method:

====
[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(oauth2Login()
            .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
        )
    );
----
====

[[testing-oauth2-login-claims]]
===== Configuring Claims

While granted authorities are quite common across all of Spring Security, we also have claims, in the case of OAuth 2.0.

Suppose, for example, that you have a `user_id` attribute that indicates the user's ID in your system.
You can access it in a controller:

====
[source,java]
----
@GetMapping("/endpoint")
public String foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    String userId = oauth2User.getAttribute("user_id");
    // ...
}
----
====

In that case, you can specify that attribute with the `attributes()` method:

====
[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(oauth2Login()
                .attributes(attrs -> attrs.put("user_id", "1234"))
        )
    );
----
====

[[testing-oauth2-login-user]]
===== Additional Configurations

There are additional methods, too, for further configuring the authentication, depending on what data your controller expects:

* `clientRegistration(ClientRegistration)`: For configuring the associated `OAuth2AuthorizedClient` with a given `ClientRegistration`
* `oauth2User(OAuth2User)`: For configuring the complete `OAuth2User` instance

That last one is handy if you:
* Have your own implementation of `OAuth2User`
* Need to change the name attribute

For example, suppose your authorization server sends the principal name in the `user_name` claim instead of in the `sub` claim.
In that case, you can configure an `OAuth2User` by hand:

====
[source,java]
----
OAuth2User oauth2User = new DefaultOAuth2User(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        Collections.singletonMap("user_name", "foo_user"),
        "user_name");

mvc
    .perform(get("/endpoint")
        .with(oauth2Login().oauth2User(oauth2User))
    );
----
====

[[testing-oauth2-client]]
==== Testing OAuth 2.0 Clients

Independent of your user authenticates, you may have other tokens and client registrations that are in play for the request you are testing.
For example, your controller may rely on the client credentials grant to get a token that is not associated with the user at all:

====
[source,java]
----
@GetMapping("/endpoint")
public String foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    return this.webClient.get()
        .attributes(oauth2AuthorizedClient(authorizedClient))
        .retrieve()
        .bodyToMono(String.class)
        .block();
}
----
====

Simulating this handshake with the authorization server can be cumbersome.
Instead, you can use `SecurityMockMvcRequestPostProcessor#oauth2Client` to add a `OAuth2AuthorizedClient` into a mock `OAuth2AuthorizedClientRepository`:

====
[source,java]
----
mvc
    .perform(get("/endpoint").with(oauth2Client("my-app")));
----
====

This line creates an `OAuth2AuthorizedClient` that has a `ClientRegistration`, an `OAuth2AccessToken`, and a resource owner name.

Specifically, it includes a `ClientRegistration` with a client ID of `test-client` and a client secret of `test-secret`:

====
[source,java]
----
assertThat(authorizedClient.getClientRegistration().getClientId()).isEqualTo("test-client");
assertThat(authorizedClient.getClientRegistration().getClientSecret()).isEqualTo("test-secret");
----
====

It also includes a resource owner whose name is `user`:

====
[source,json]
----
assertThat(authorizedClient.getPrincipalName()).isEqualTo("user");
----
====

Finally, it includes an `OAuth2AccessToken` with only one scope, `read`:

====
[source,java]
----
assertThat(authorizedClient.getAccessToken().getScopes()).hasSize(1);
assertThat(authorizedClient.getAccessToken().getScopes()).containsExactly("read");
----
====

You can then retrieve the client as usual, by using `@RegisteredOAuth2AuthorizedClient` in a controller method.

[[testing-oauth2-client-scopes]]
===== Configuring Scopes

In many circumstances, the OAuth 2.0 access token comes with a set of scopes.
Your controller can inspect these scopes:

====
[source,java]
----
@GetMapping("/endpoint")
public String foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    Set<String> scopes = authorizedClient.getAccessToken().getScopes();
    if (scopes.contains("message:read")) {
        return this.webClient.get()
            .attributes(oauth2AuthorizedClient(authorizedClient))
            .retrieve()
            .bodyToMono(String.class)
            .block();
    }
    // ...
}
----
====

Then you can configure each scope by using the `accessToken()` method:

====
[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(oauth2Client("my-app")
            .accessToken(new OAuth2AccessToken(BEARER, "token", null, null, Collections.singleton("message:read"))))
        )
    );
----
====

[[testing-oauth2-client-registration]]
===== Additional Configurations

You can use additional methods to further configure the authentication, depending on what data your controller expects:

* `principalName(String)`: For configuring the resource owner name
* `clientRegistration(Consumer<ClientRegistration.Builder>)`: For configuring the associated `ClientRegistration`
* `clientRegistration(ClientRegistration)`: For configuring the complete `ClientRegistration`

That last one is handy if you want to use a real `ClientRegistration` object.

For example, suppose that you want to use one of your application's `ClientRegistration` definitions, as specified in your `application.yml`.

In that case, your test can autowire the `ClientRegistrationRepository` and look up the one your test needs:

====
[source,java]
----
@Autowired
ClientRegistrationRepository clientRegistrationRepository;

// ...

mvc
    .perform(get("/endpoint")
        .with(oauth2Client()
            .clientRegistration(this.clientRegistrationRepository.findByRegistrationId("facebook"))));
----
====

[[testing-jwt]]
==== Testing JWT Authentication

To make an authorized request on a resource server, you need a bearer token.

If your resource server is configured for JWTs, the bearer token needs to be signed and then encoded according to the JWT specification.
All of this can be quite daunting, especially when this is not the focus of your test.

Fortunately, there are a number of ways that you can overcome this difficulty and let your tests focus on authorization and not on representing bearer tokens.
We look at two of them in the next two subsections.

===== `jwt() RequestPostProcessor`

The first way is with a `RequestPostProcessor`.
The simplest of these looks something like this:

====
[source,java]
----
mvc
    .perform(get("/endpoint").with(jwt()));
----
====

This line creates a mock `Jwt` and passes it correctly through any authentication APIs so that itis available for your authorization mechanisms to verify.

By default, the `JWT` that it creates has the following characteristics:

====
[source,json]
----
{
  "headers" : { "alg" : "none" },
  "claims" : {
    "sub" : "user",
    "scope" : "read"
  }
}
----
====

The resulting `Jwt`, were it tested, would pass in the following way:

====
[source,java]
----
assertThat(jwt.getTokenValue()).isEqualTo("token");
assertThat(jwt.getHeaders().get("alg")).isEqualTo("none");
assertThat(jwt.getSubject()).isEqualTo("sub");
GrantedAuthority authority = jwt.getAuthorities().iterator().next();
assertThat(authority.getAuthority()).isEqualTo("read");
----
====

You can configure these values.

You can configure any headers or claims with their corresponding methods:

====
[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(jwt().jwt(jwt -> jwt.header("kid", "one").claim("iss", "https://idp.example.org"))));
----

[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(jwt().jwt(jwt -> jwt.claims(claims -> claims.remove("scope")))));
----
====

The `scope` and `scp` claims are processed the same way here as they are in a normal bearer token request.
However, you can override this by providing the list of `GrantedAuthority` instances that you need for your test:

====
[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(jwt().authorities(new SimpleGrantedAuthority("SCOPE_messages"))));
----
====

Alternatively, if you have a custom `Jwt` to `Collection<GrantedAuthority>` converter, you can also use that to derive the authorities:

====
[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(jwt().authorities(new MyConverter())));
----
====

You can also specify a complete `Jwt`, which you can do with `{security-api-url}org/springframework/security/oauth2/jwt/Jwt.Builder.html[`Jwt.Builder`]`:

====
[source,java]
----
Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .claim("scope", "read");

mvc
    .perform(get("/endpoint")
        .with(jwt().jwt(jwt)));
----
====

===== `authentication()` `RequestPostProcessor`

The second way is by using the `authentication()` `RequestPostProcessor`.
Essentially, you can instantiate your own `JwtAuthenticationToken` and provide it in your test:

====
[source,java]
----
Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .build();
Collection<GrantedAuthority> authorities = AuthorityUtils.createAuthorityList("SCOPE_read");
JwtAuthenticationToken token = new JwtAuthenticationToken(jwt, authorities);

mvc
    .perform(get("/endpoint")
        .with(authentication(token)));
----
====

Note that, as an alternative to these approaches, you can also mock the `JwtDecoder` bean itself with a `@MockBean` annotation.

[[testing-opaque-token]]
==== Testing Opaque Token Authentication

Similar to <<testing-jwt,JWTs>>, opaque tokens require an authorization server to verify their validity, which can make testing more difficult.
To help with that, Spring Security has test support for opaque tokens.

Suppose that you have a controller that retrieves the authentication as a `BearerTokenAuthentication`:

====
[source,java]
----
@GetMapping("/endpoint")
public String foo(BearerTokenAuthentication authentication) {
    return (String) authentication.getTokenAttributes("sub");
}
----
====

In that case, we can tell Spring Security to include a default `BearerTokenAuthentication` by using the `SecurityMockMvcRequestPostProcessors#opaqueToken` method:

====
[source,java]
----
mvc
    .perform(get("/endpoint").with(opaqueToken()));
----
====

This line configures the associated `MockHttpServletRequest` with a `BearerTokenAuthentication` that includes a simple `OAuth2AuthenticatedPrincipal`, a `Map` of attributes, and a `Collection` of granted authorities.

Specifically, it includes a `Map` with a key/value pair of `sub`/`user`:

====
[source,java]
----
assertThat((String) token.getTokenAttributes().get("sub")).isEqualTo("user");
----
====

It also includes a `Collection` of authorities with only one authority, `SCOPE_read`:

[source,java]
----
assertThat(token.getAuthorities()).hasSize(1);
assertThat(token.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));
----

Spring Security does the necessary work to make sure that the `BearerTokenAuthentication` instance is available for your controller methods.

[[testing-opaque-token-authorities]]
===== Configuring Authorities

In many circumstances, your method is protected by filter or method security and needs your `Authentication` to have certain granted authorities to allow the request.

In this case, you can supply the granted authorities you need by using the `authorities()` method:

====
[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(opaqueToken()
            .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
        )
    );
----
====

[[testing-opaque-token-attributes]]
===== Configuring Claims

While granted authorities are quite common across all of Spring Security, we also have attributes, in the case of OAuth 2.0.

Suppose, for example, that you have a `user_id` attribute that indicates the user's ID in your system.
You can access it in a controller:

====
[source,java]
----
@GetMapping("/endpoint")
public String foo(BearerTokenAuthentication authentication) {
    String userId = (String) authentication.getTokenAttributes().get("user_id");
    // ...
}
----
====

In that case, you want to specify that attribute with the `attributes()` method:

====
[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(opaqueToken()
                .attributes(attrs -> attrs.put("user_id", "1234"))
        )
    );
----
====

[[testing-opaque-token-principal]]
===== Additional Configurations

There are additional methods, too, for further configuring the authentication. It simply depends on what data your controller expects.

One such method is `principal(OAuth2AuthenticatedPrincipal)`, which you can use to configure the complete `OAuth2AuthenticatedPrincipal` instance that underlies the `BearerTokenAuthentication`

It is useful if you:
* Have your own implementation of `OAuth2AuthenticatedPrincipal`
* Want to specify a different principal name

For example, suppose that your authorization server sends the principal name in the `user_name` attribute instead of the `sub` attribute.
In that case, you can configure an `OAuth2AuthenticatedPrincipal` by hand:

====
[source,java]
----
Map<String, Object> attributes = Collections.singletonMap("user_name", "foo_user");
OAuth2AuthenticatedPrincipal principal = new DefaultOAuth2AuthenticatedPrincipal(
        (String) attributes.get("user_name"),
        attributes,
        AuthorityUtils.createAuthorityList("SCOPE_message:read"));

mvc
    .perform(get("/endpoint")
        .with(opaqueToken().principal(principal))
    );
----
====

Note that, as an alternative to using `opaqueToken()` test support, you can also mock the `OpaqueTokenIntrospector` bean itself with a `@MockBean` annotation.

=== SecurityMockMvcRequestBuilders

Spring MVC Test also provides a `RequestBuilder` interface that you can use to create the `MockHttpServletRequest` for your test.
Spring Security provides a few `RequestBuilder` implementations that you can use to make testing easier.
To use Spring Security's `RequestBuilder` implementations, use the following static import:

====
[source,java]
----
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestBuilders.*;
----
====

==== Testing Form-based Authentication

You can create a request to test a form-based authentication using Spring Security's testing support.
For example, the following line submits a POST to `/login` with a username of `user`, a password of `password`, and a valid CSRF token:

====
[source,java]
----
mvc
	.perform(formLogin())
----
====

It is easy to customize the request.
For example, the following line submits a POST to `/auth` with a username of `admin`, a password of `pass`, and a valid CSRF token:

====
[source,java]
----
mvc
	.perform(formLogin("/auth").user("admin").password("pass"))
----
====

You can also customize the parameters names on which the username and password are included.
For example, the following line modifies the preceding request to include the username on the HTTP parameter named `u` and the password on the HTTP parameter named `p`:

====
[source,java]
----
mvc
	.perform(formLogin("/auth").user("u","admin").password("p","pass"))
----
====

[[test-logout]]
==== Testing Logout

A minor but still useful use case for Spring Security's testing support is to test logging out.
The following example submits a POST to `/logout` with a valid CSRF token:

====
[source,java]
----
mvc
	.perform(logout())
----
====

You can also customize the URL to which to post.
The following example submits a POST to `/signout` with a valid CSRF token:

====
[source,java]
----
mvc
	.perform(logout("/signout"))
----
====

=== SecurityMockMvcResultMatchers

At times, you may want to make various security-related assertions about a request.
To accommodate this need, Spring Security's testing support implements Spring MVC Test's `ResultMatcher` interface.
To use Spring Security's `ResultMatcher` implementations, use the following static import:

====
[source,java]
----
import static org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.*;
----
====

==== Unauthenticated Assertion

At times, you may want to assert that there is no authenticated user associated with the result of a `MockMvc` invocation.
For example, you might want to test submitting an invalid username and password and verify that no user is authenticated.
You can do so with Spring Security's testing support by using something like the following:

====
[source,java]
----
mvc
	.perform(formLogin().password("invalid"))
	.andExpect(unauthenticated());
----
====

==== Authenticated Assertion

Often, you must assert that an authenticated user exists.
For example, you may want to verify that we authenticated successfully.
You could verify that a form-based login was successful:

====
[source,java]
----
mvc
	.perform(formLogin())
	.andExpect(authenticated());
----
====

To assert the roles of the user, you can refine our previous code as follows:

====
[source,java]
----
mvc
	.perform(formLogin().user("admin"))
	.andExpect(authenticated().withRoles("USER","ADMIN"));
----
====

Similarly, you can verify the username:

====
[source,java]
----
mvc
	.perform(formLogin().user("admin"))
	.andExpect(authenticated().withUsername("admin"));
----
====

You can also combine the assertions:

====
[source,java]
----
mvc
	.perform(formLogin().user("admin").roles("USER","ADMIN"))
	.andExpect(authenticated().withUsername("admin"));
----
====

We can also make arbitrary assertions on the authentication:

====
[source,java]
----
mvc
	.perform(formLogin())
	.andExpect(authenticated().withAuthentication(auth ->
		assertThat(auth).isInstanceOf(UsernamePasswordAuthenticationToken.class)));
----
====
