[[webflux-roac]]
= @RegisteredOAuth2AuthorizedClient

Spring Security allows resolving an access token by using `@RegisteredOAuth2AuthorizedClient`.

[NOTE]
====
You can find a working example in the {gh-samples-url}/boot/oauth2webclient-webflux[OAuth 2.0 WebClient WebFlux sample].
====

After configuring Spring Security for <<webflux-oauth2-login,OAuth2 Login>> or as an <<webflux-oauth2-client,OAuth2 Client>>, you can resolve an `OAuth2AuthorizedClient` by using the following:

====
.Java
[source,java,role="primary"]
----
@GetMapping("/explicit")
Mono<String> explicit(@RegisteredOAuth2AuthorizedClient("client-id") OAuth2AuthorizedClient authorizedClient) {
	// ...
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@GetMapping("/explicit")
fun explicit(@RegisteredOAuth2AuthorizedClient("client-id") authorizedClient: OAuth2AuthorizedClient?): Mono<String> {
    // ...
}
----
====

This code integrates into Spring Security to provide the following features:

* Spring Security automatically refreshes expired tokens (if a refresh token is present).
* If an access token is requested and not present, Spring Security automatically requests the access token.
** For `authorization_code`, this involves performing the redirect and then replaying the original request.
** For `client_credentials`, the token is simply requested and saved.

If the user authenticated by using `oauth2Login()`, the `client-id` is optional.
For example, the following would work:

====
.Java
[source,java,role="primary"]
----
@GetMapping("/implicit")
Mono<String> implicit(@RegisteredOAuth2AuthorizedClient OAuth2AuthorizedClient authorizedClient) {
	// ...
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@GetMapping("/implicit")
fun implicit(@RegisteredOAuth2AuthorizedClient authorizedClient: OAuth2AuthorizedClient?): Mono<String> {
    // ...
}
----
====

This approach is convenient if the user always authenticates with OAuth2 Login and an access token from the same authorization server is needed.
